{"version":3,"file":"technoidentity-utils.cjs.production.min.js","sources":["../src/assertions.ts","../src/common.ts","../src/iotsUtils.ts","../src/checked.ts","../src/dateOnly.ts","../src/enums.ts","../src/obj.ts","../src/isTcomb.ts","../src/emptyFromValue.ts","../src/fn.ts","../src/id.ts","../src/tcombRefinements.ts","../src/rtFromSpec.ts","../src/stringUtils.ts","../src/timeOnly.ts","../src/objUtils.ts","../src/empty.ts","../src/emptyFromRT.ts","../src/rtFromValue.ts","../src/coercions.ts"],"sourcesContent":["// copied from tiny-warning package\nexport function warn(condition: unknown, message: string): void {\n  if (condition) {\n    return\n  }\n\n  const text: string = `Warning: ${message}`\n\n  // tslint:disable-next-line no-console\n  console.warn(text)\n\n  // Throwing an error and catching it immediately to improve debugging.\n  // A consumer can use 'pause on caught exceptions'\n  // https://github.com/facebook/react/issues/4216\n  try {\n    throw Error(text)\n    // tslint:disable-next-line no-empty\n  } catch (x) {}\n}\n\nexport function debug(condition: unknown, message: string): void {\n  if (process.env.NODE_ENV === 'development') {\n    warn(condition, message)\n  }\n}\n\nexport function fatal(message?: string): never {\n  if (process.env.NODE_ENV === 'production') {\n    // In production we strip the message but still throw\n    throw new Error('Invariant failed')\n  } else {\n    // When not in production we allow the message to pass through\n    // *This block will be removed in production builds*\n    throw new Error(`Invariant failed: ${message || ''}`)\n  }\n}\n\nexport function error(message?: string): void {\n  if (process.env.NODE_ENV === 'development') {\n    fatal(message)\n  }\n}\n\n// copied from tiny-invariant package\nexport function verify(condition: unknown, message?: string): void {\n  if (!condition) {\n    fatal(message)\n  }\n}\n\nexport function assert(condition: unknown, message?: string): void {\n  if (process.env.NODE_ENV === 'development') {\n    verify(condition, message)\n  }\n}\n","import { startOfDay } from 'date-fns'\nimport { TypeOf, union } from 'io-ts'\nimport { date } from 'io-ts-types/lib/date'\nimport { DateFromISOString } from 'io-ts-types/lib/DateFromISOString'\nimport { NonUndefined } from 'utility-types'\nimport { assert } from './assertions'\n\n// tslint:disable no-loop-statement no-array-mutation no-object-mutation no-null-keyword\n\nexport function freeze<T>(v: T): Readonly<T> {\n  return process.env.NODE_ENV !== 'production' ? Object.freeze(v) : v\n}\n\nexport function jsonStringify(obj: object): string {\n  return JSON.stringify(obj, null, 2)\n}\n\nexport function nop(..._: any[]): any {\n  return undefined\n}\n\nfunction rangeInternal(\n  start: number,\n  stop: number,\n  step: number = 1,\n): ReadonlyArray<number> {\n  assert(step > 0)\n\n  const result: number[] = []\n  for (let i: number = start; i < stop; i += step) {\n    result.push(i)\n  }\n  return result\n}\n\nexport function range(\n  start: number,\n  stop?: number,\n  step?: number,\n): ReadonlyArray<number> {\n  return stop ? rangeInternal(start, stop, step) : rangeInternal(0, start)\n}\n\nexport function repeatedly<T>(\n  n: number,\n  f: (index: number) => T,\n): ReadonlyArray<T> {\n  const result: T[] = []\n  for (let i: number = 0; i < n; i++) {\n    result.push(f(i))\n  }\n  return result\n}\n\nexport const buildArray: typeof repeatedly = repeatedly\n\nexport function keys<T extends Object>(obj: T): ReadonlyArray<keyof T> {\n  return Object.keys(obj) as ReadonlyArray<keyof T>\n}\n\nexport function buildObject<T extends {}, R>(\n  obj: T,\n  f: (value: T[typeof key], key: keyof T) => R,\n): Record<keyof T, NonUndefined<R>> {\n  const result: any = {}\n  for (const k of keys(obj)) {\n    const v: any = f(obj[k], k)\n    if (v !== undefined) {\n      result[k] = v\n    }\n  }\n  return result\n}\n\nexport function today(): Date {\n  return startOfDay(new Date())\n}\n\nexport async function timeout<T>(delay: number, f: () => T = nop): Promise<T> {\n  return new Promise(resolve => setTimeout(() => resolve(f()), delay))\n}\n\nexport async function interval<T>(\n  interval: number,\n  f: () => T = nop,\n): Promise<T> {\n  return new Promise(resolve => setInterval(() => resolve(f()), interval))\n}\n\n// tslint:disable-next-line: typedef\nexport const ISODate = union([date, DateFromISOString])\n\nexport type ISODate = TypeOf<typeof ISODate>\n\nexport function pick<T extends {}, K extends keyof T>(\n  obj: T,\n  ks: ReadonlyArray<K>,\n): Pick<T, K> {\n  const result: any = {}\n\n  for (const k of keys(obj)) {\n    if (ks.includes(k as K)) {\n      result[k] = obj[k]\n    }\n  }\n\n  return result\n}\n\nexport function omit<T extends {}, K extends keyof T>(\n  obj: T,\n  ks: ReadonlyArray<K>,\n): Omit<T, K> {\n  const result: any = {}\n\n  for (const k of keys(obj)) {\n    if (!ks.includes(k as K)) {\n      result[k] = obj[k]\n    }\n  }\n\n  return result\n}\n","import { Either, isRight } from 'fp-ts/lib/Either'\nimport {\n  Errors,\n  ExactType,\n  InterfaceType,\n  IntersectionType,\n  literal,\n  PartialType,\n  Props,\n  ReadonlyType,\n  string,\n  Type,\n} from 'io-ts'\nimport { PathReporter } from 'io-ts/lib/PathReporter'\nimport { assert, fatal } from './assertions'\nimport { omit, pick } from './common'\nimport { ObjType } from './obj'\n// tslint:disable readonly-array array-type readonly-keyword\n\nexport function cast<A, O, I>(spec: Type<A, O, I>, args: I): A {\n  const decoded: Either<Errors, A> = spec.decode(args)\n  return isRight(decoded)\n    ? decoded.right\n    : fatal(PathReporter.report(decoded).join('\\n'))\n}\n\nexport const verifyCast: typeof cast = cast\n\nexport function assertCast<A, O, I>(\n  spec: Type<A, O, I>,\n  args: I,\n): A | undefined {\n  const decoded: Either<Errors, A> = spec.decode(args)\n  assert(spec.is(args), PathReporter.report(decoded).join('\\n'))\n  return isRight(decoded) ? decoded.right : undefined\n}\n\nexport const debugCast: typeof assertCast = assertCast\n\nexport async function rejected<T>(\n  decoded: Either<Errors, T> | string,\n): Promise<T> {\n  return Promise.reject(\n    new Error(\n      string.is(decoded) ? decoded : PathReporter.report(decoded).join('\\n'),\n    ),\n  )\n}\n\nexport async function toPromise<T>(either: Either<Errors, T>): Promise<T> {\n  return isRight(either) ? either.right : rejected(either)\n}\n\n// export function opt<P extends Props>(\n//   props: P,\n//   name?: string,\n// ): ReadonlyC<PartialC<P>> {\n//   return readonly(partial(props), name)\n// }\n\n// export function req<P extends Props>(\n//   props: P,\n//   name?: string,\n// ): ReadonlyC<TypeC<P>> {\n//   return readonly(type(props), name)\n// }\n\n// export function props<O extends Props, R extends Props>(\n//   optional: O,\n//   required: R,\n//   name?: string,\n// ): IntersectionC<[ReadonlyC<PartialC<O>>, ReadonlyC<TypeC<R>>]> {\n//   return intersection(\n//     [readonly(partial(optional)), readonly(type(required))],\n//     name,\n//   )\n// }\n\nexport const lit: typeof literal = literal\n\nexport interface GotPropsIntersection\n  extends IntersectionType<[GotProps, GotProps, ...Array<GotProps>]> {}\n\nexport interface GotPropsReadonly extends ReadonlyType<GotProps> {}\n\nexport type GotPropsOnType = GotPropsReadonly | ExactType<any>\n\nexport type GotPropsOnProps =\n  | InterfaceType<any>\n  | PartialType<any>\n  | ObjType<any, any, any, any>\n\nexport type GotProps = GotPropsIntersection | GotPropsOnProps | GotPropsOnType\n\n// export function getProps<T extends Mixed>(codec: T & GotProps): Props {\n//   switch (codec._tag) {\n//     case 'ReadonlyType':\n//     case 'ExactType':\n//       return getProps(codec.type)\n//     case 'InterfaceType':\n//     case 'ObjType':\n//     case 'PartialType':\n//       return codec.props\n//     case 'IntersectionType':\n//       return codec.types.reduce<Props>(\n//         (props, type) => ({ ...props, ...getProps(type as any) }),\n//         {},\n//       )\n//   }\n// }\n\n// export function getProp<T extends Mixed>(\n//   codec: T & GotProps,\n//   key: string,\n// ): Mixed | undefined {\n//   switch (codec._tag) {\n//     case 'ReadonlyType':\n//     case 'ExactType':\n//       return getProp(codec.type, key)\n//     case 'InterfaceType':\n//     case 'ObjType':\n//     case 'PartialType':\n//       return codec.props[key]\n//     case 'IntersectionType':\n//       for (const t of codec.types) {\n//         const result: Mixed | undefined = getProp(t as any, key)\n//         if (result !== undefined) {\n//           return result\n//         }\n//       }\n//       return undefined\n//   }\n// }\n\nexport function pickProps<T extends Props, K extends keyof T>(\n  props: T,\n  keys: ReadonlyArray<K>,\n): Pick<T, K> {\n  return pick(props, keys)\n}\n\nexport function omitProps<T extends Props, K extends keyof T>(\n  props: T,\n  keys: ReadonlyArray<K>,\n): Omit<T, K> {\n  return omit(props, keys)\n}\n","import { Mixed, tuple, TupleC, TypeOf } from 'io-ts'\nimport { cast } from './iotsUtils'\n\n// tslint:disable readonly-array\n\n// TODO: revisit replacing tuple once ts 3.7 releases with circular references support\n\nexport function tupleChecked<\n  T extends [Mixed, ...Mixed[]],\n  A extends TypeOf<TupleC<T>> & any[],\n  R extends Mixed\n>(argSpecs: TupleC<T>, resultSpec: R, f: (...args: A) => TypeOf<R>): typeof f {\n  return (...args) => {\n    cast(argSpecs, args)\n\n    return cast(resultSpec, f(...args))\n  }\n}\n\nexport function checked<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  D extends Mixed,\n  E extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C, D, E],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  D extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C, D],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked<A extends Mixed, B extends Mixed, R extends Mixed>(\n  codecs: [A, B],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked<A extends Mixed, R extends Mixed>(\n  codecs: [A],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked(\n  codecs: any,\n  resultSpec: any,\n  f: (...args: any[]) => any,\n): typeof f {\n  return tupleChecked(tuple(codecs), resultSpec, f)\n}\n\nexport function tupleCheckedAsync<\n  T extends [Mixed, ...Mixed[]],\n  A extends TypeOf<TupleC<T>> & any[],\n  R extends Mixed\n>(\n  argSpecs: TupleC<T>,\n  resultSpec: R,\n  f: (...args: A) => Promise<TypeOf<typeof resultSpec>>,\n): typeof f {\n  return async (...args) => {\n    cast(argSpecs, args)\n\n    return cast(resultSpec, await f(...args))\n  }\n}\n\nexport function checkedAsync<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  D extends Mixed,\n  E extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C, D, E],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  D extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C, D],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync<A extends Mixed, B extends Mixed, R extends Mixed>(\n  codecs: [A, B],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync<A extends Mixed, R extends Mixed>(\n  codecs: [A],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync(\n  codecs: any,\n  resultSpec: any,\n  f: (...args: any[]) => any,\n): typeof f {\n  return tupleCheckedAsync(tuple(codecs), resultSpec, f)\n}\n","import { brand, BrandC, Branded } from 'io-ts'\nimport { date, DateC } from 'io-ts-types/lib/date'\nexport interface DateOnlyBrand {\n  readonly DateOnly: unique symbol\n}\n\nexport const DateOnly: BrandC<DateC, DateOnlyBrand> = brand(\n  date,\n  (n): n is Branded<Date, DateOnlyBrand> => date.is(n),\n  'DateOnly',\n)\n\nexport type DateOnly = Branded<Date, DateOnlyBrand>\n","import { failure, identity, string, success, Type } from 'io-ts'\n\n// tslint:disable no-class readonly-array\n\nexport class EnumType<D extends string[], A> extends Type<A> {\n  readonly _tag: 'EnumType' = 'EnumType'\n\n  constructor(\n    readonly keys: D,\n    name: string,\n    is: EnumType<D, A>['is'],\n    validate: EnumType<D, A>['validate'],\n    encode: EnumType<D, A>['encode'],\n  ) {\n    super(name, is, validate, encode)\n  }\n}\n\nexport interface EnumC<D extends string[]> extends EnumType<D, D[number]> {}\n\nexport function enums<T extends string[]>(\n  name: string | undefined,\n  ...keys: T\n): EnumC<T> {\n  function is(u: unknown): u is T[number] {\n    return string.is(u) && keys.includes(u)\n  }\n\n  return new EnumType(\n    keys,\n    name || `Enum<${keys.join(' | ')}>`,\n    is,\n    (u, c) => (is(u) ? success(u) : failure(u, c)),\n    identity,\n  )\n}\n\nexport function enumerate<T extends string[]>(...keys: T): EnumC<T> {\n  return enums(undefined, ...keys)\n}\n","import {\n  exact,\n  ExactC,\n  intersection,\n  IntersectionC,\n  Mixed,\n  partial,\n  PartialC,\n  Props,\n  readonly,\n  ReadonlyC,\n  Type,\n  type,\n  TypeC,\n  TypeOf,\n} from 'io-ts'\n\n// tslint:disable no-class readonly-array\n\ntype OptSpec<Opt extends Props> = ReadonlyC<PartialC<Opt>>\ntype ReqSpec<Req extends Props> = ReadonlyC<TypeC<Req>>\ntype ObjSpec<Opt extends Props, Req extends Props> = IntersectionC<\n  [OptSpec<Opt>, ReqSpec<Req>]\n>\ntype ExactObjSpec<Opt extends Props, Req extends Props> = ExactC<\n  IntersectionC<[OptSpec<Opt>, ReqSpec<Req>]>\n>\n\n// type NoEmptyIntersect<Opt extends Props, Req extends Props> = {} extends Opt\n//   ? {} extends Req\n//     ? Opt\n//     : Req\n//   : Opt & Req\n\nexport class ObjType<\n  Opt extends Props,\n  Req extends Props,\n  A,\n  O = A,\n  I = unknown\n> extends Type<A, O, I> {\n  readonly _tag: 'ObjType' = 'ObjType'\n\n  constructor(\n    readonly optional: Opt,\n    readonly required: Req,\n    readonly props: Opt & Req,\n    spec: Type<A, O, I>,\n    name: string,\n  ) {\n    super(name, spec.is, spec.validate, spec.encode)\n  }\n}\n\nexport interface ObjC<Opt extends Props, Req extends Props>\n  extends ObjType<\n    Opt,\n    Req,\n    ObjSpec<Opt, Req>['_A'],\n    ObjSpec<Opt, Req>['_O'],\n    ObjSpec<Opt, Req>['_I']\n  > {}\n\nfunction newObj<Opt extends Props, Req extends Props>(\n  optional: Opt,\n  required: Req,\n  name?: string,\n): ObjC<Opt, Req> {\n  const spec: ObjSpec<Opt, Req> = intersection([\n    readonly(partial(optional)),\n    readonly(type(required)),\n  ])\n\n  return new ObjType(\n    optional,\n    required,\n    { ...optional, ...required },\n    spec,\n    name || spec.name,\n  )\n}\n\nexport type ObjPropsOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['props']\n\nexport type ObjReqOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['required']\n\nexport type ObjOptOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['optional']\n\nexport type ObjTypeOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['_A']\n\nexport type ObjOutPutOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['_O']\n\nexport type ObjInputOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['_I']\n\nexport type AnyObj = Mixed & ObjC<any, any>\n\nexport interface ExactObjC<Opt extends Props, Req extends Props>\n  extends ObjType<\n    Opt,\n    Req,\n    ExactObjSpec<Opt, Req>['_A'],\n    ExactObjSpec<Opt, Req>['_O'],\n    ExactObjSpec<Opt, Req>['_I']\n  > {}\n\n// @TODO: need ability to distinguish ObjType from Exact ObjType\nfunction newExactObj<Opt extends Props, Req extends Props>(\n  optional: Opt,\n  required: Req,\n  name?: string,\n): ExactObjC<Opt, Req> {\n  const spec: ExactObjSpec<Opt, Req> = exact(\n    intersection([readonly(partial(optional)), readonly(type(required))]),\n  )\n  return new ObjType(\n    optional,\n    required,\n    { ...optional, ...required },\n    spec,\n    name || spec.name,\n  )\n}\n\nexport function obj<Opt extends Props, Req extends Props>(\n  optional: Opt,\n  required: Req,\n  name?: string,\n): ObjC<Opt, Req> {\n  return newObj(optional, required, name)\n}\n\nexport function exactObj<Opt extends Props, Req extends Props>(\n  optional: Opt,\n  required: Req,\n  name?: string,\n): ObjC<Opt, Req> {\n  return newExactObj(optional, required, name)\n}\n\nexport function req<Req extends Props>(\n  required: Req,\n  name?: string,\n): ObjC<{}, Req> {\n  return obj({}, required, name)\n}\n\nexport function opt<Opt extends Props>(\n  optional: Opt,\n  name?: string,\n): ObjC<Opt, {}> {\n  return obj(optional, {}, name)\n}\n\nexport function getProps<Spec extends AnyObj>(spec: AnyObj): Spec['props'] {\n  return spec.props\n}\n\nexport function getProp<Spec extends AnyObj, K extends keyof TypeOf<Spec>>(\n  spec: Spec,\n  prop: K,\n): Spec['props'][K] {\n  return spec.props[prop]\n}\n","import t, {\n  Constructor,\n  Dict,\n  Enums,\n  Interface,\n  Intersection,\n  Irreducible,\n  List,\n  Maybe,\n  Struct,\n  Tuple,\n  Type,\n  Union,\n} from 'tcomb'\n\nexport function isType<T>(spec: Constructor<T>): spec is Type<T> {\n  return t.isType(spec)\n}\n\nexport function isStruct<T>(spec: Type<T>): spec is Struct<T> {\n  return spec.meta.kind === 'struct'\n}\n\nexport function isInterface<T>(spec: Type<T>): spec is Interface<T> {\n  return spec.meta.kind === 'interface'\n}\n\nexport function isIntersection<T>(spec: Type<T>): spec is Intersection<T> {\n  return spec.meta.kind === 'intersection'\n}\n\nexport function isMaybe<T>(spec: Type<void | T>): spec is Maybe<T> {\n  return spec.meta.kind === 'maybe'\n}\n\nexport function isUnion<T>(spec: Type<T>): spec is Union<T> {\n  return spec.meta.kind === 'union'\n}\n\nexport function isEnums(spec: Type<string>): spec is Enums {\n  return spec.meta.kind === 'enums'\n}\n\nexport function isTuple<T>(spec: Type<T>): spec is Tuple<T> {\n  return spec.meta.kind === 'tuple'\n}\n\n// tslint:disable-next-line: readonly-array\nexport function isList<T>(spec: Type<T[]>): spec is List<T> {\n  return spec.meta.kind === 'list'\n}\n\n// tslint:disable-next-line: readonly-keyword\nexport function isDict<T>(spec: Type<{ [key: string]: T }>): spec is Dict<T> {\n  return spec.meta.kind === 'dict'\n}\n\nexport function isIrreducible<T>(spec: Type<T>): spec is Irreducible<T> {\n  return spec.meta.kind === 'irreducible'\n}\n\nexport function isInteger(spec: Type<any>): boolean {\n  return spec.meta.kind === 'subtype' && spec.meta.name === 'Integer'\n}\n","import { Array, boolean, number, string, UnknownRecord } from 'io-ts'\nimport { date } from 'io-ts-types/lib/date'\nimport { warn } from './assertions'\nimport { buildObject, today } from './common'\n\nfunction emptyFromPrimitiveValue(v: unknown): any {\n  if (number.is(v)) {\n    return 0\n  }\n\n  if (string.is(v)) {\n    return ''\n  }\n\n  if (boolean.is(v)) {\n    return false\n  }\n\n  // tslint:disable-next-line: no-null-keyword\n  if (v == null) {\n    return v\n  }\n\n  if (date.is(v)) {\n    return today()\n  }\n\n  warn(false, `Unsupported value ${v}`)\n}\n\nfunction emptyFromObjectValue<T extends {}>(value: T): T {\n  return buildObject(value, emptyFromValue) as any\n}\n\nexport const emptyFromValue: <T>(value: T) => T = value => {\n  if (Array.is(value)) {\n    return []\n  }\n\n  if (UnknownRecord.is(value)) {\n    return emptyFromObjectValue(value)\n  }\n\n  return emptyFromPrimitiveValue(value)\n}\n","import { failure, identity, success, Type } from 'io-ts'\n\n// tslint:disable no-class no-this\n\nexport class FnType<F extends Function> extends Type<F> {\n  readonly _tag: 'FnType' = 'FnType'\n\n  constructor() {\n    super(\n      'FnType',\n      (u): u is F => typeof u === 'function',\n\n      (u, c) => (this.is(u) ? success(u) : failure(u, c)),\n      identity,\n    )\n  }\n}\n\nexport interface FnC<F extends Function> extends FnType<F> {}\n\nexport function fn<F extends Function>(): FnC<F> {\n  return new FnType<F>()\n}\n","import { brand, BrandC, Branded, Int, Mixed, string, TypeOf } from 'io-ts'\n\n// tslint:disable typedef\n\nexport function id<T extends Mixed>(\n  inner: T,\n  name?: string,\n): BrandC<T, { readonly id: symbol }> {\n  return brand(\n    inner,\n    (n): n is Branded<TypeOf<T>, { readonly id: unique symbol }> => inner.is(n),\n    name || `id<${inner.name}`,\n  )\n}\n\nexport const IntID = id(Int, 'IntID')\nexport type IntID = TypeOf<typeof IntID>\n\nexport const StrID = id(string, 'StrID')\nexport type StrID = TypeOf<typeof IntID>\n","import { compareAsc } from 'date-fns'\nimport t from 'tcomb'\n\n// tslint:disable typedef\n\nexport const Positive = t.refinement(t.Number, n => n >= 0, 'Positive')\nexport const Negative = t.refinement(t.Number, n => n <= 0, 'Negative')\nexport function Min(min: number) {\n  return t.refinement(t.Number, n => n >= min, 'Min')\n}\nexport function Max(max: number) {\n  return t.refinement(t.Number, n => n <= max, 'Max')\n}\n\nexport const PositiveInt = t.refinement(t.Integer, n => n >= 0, 'PositiveInt')\nexport const NegativeInt = t.refinement(t.Integer, n => n <= 0, 'NegativeInt')\nexport function MinInt(min: number) {\n  return t.refinement(t.Integer, n => n >= min, 'MinInt')\n}\nexport function MaxInt(max: number) {\n  return t.refinement(t.Integer, n => n <= max, 'MaxInt')\n}\n\n// eslint-disable-next-line\nconst rEmail: RegExp = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i\n// eslint-disable-next-line\nconst rUrl: RegExp = /^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i\n\nexport const Email = t.refinement(t.String, s => rEmail.test(s), 'Email')\nexport const Url = t.refinement(t.String, s => rUrl.test(s), 'Url')\nexport const Lower = t.refinement(\n  t.String,\n  s => s.toLowerCase() === s,\n  'Lowercase',\n)\nexport const Upper = t.refinement(\n  t.String,\n  s => s.toUpperCase() === s,\n  'Uppercase',\n)\nexport function Length(len: number) {\n  return t.refinement(t.String, s => s.length === len, 'StringLength')\n}\nexport function MinStringLength(min: number) {\n  return t.refinement(t.String, s => s.length >= min, 'MinStringLength')\n}\nexport function MaxStringLength(max: number) {\n  return t.refinement(t.String, s => s.length <= max, 'MaxStringLength')\n}\n\nexport function Literal(literal: string) {\n  return t.refinement(t.String, s => s === literal)\n}\n\nexport function MinDate(min: Date) {\n  return t.refinement(t.Date, d => compareAsc(min, d) <= 0, 'MinDate')\n}\nexport function MaxDate(max: Date) {\n  return t.refinement(t.Date, d => compareAsc(max, d) >= 0, 'MaxDate')\n}\n\nexport function ArrayMinLength(min: number) {\n  return t.refinement(t.Array, arr => arr.length >= min, 'ArrayMinLength')\n}\nexport function ArrayMaxLength(max: number) {\n  return t.refinement(t.Array, arr => arr.length <= max, 'ArrayMaxLength')\n}\n","import {\n  AnyArrayType,\n  ArrayType,\n  BooleanType,\n  ExactType,\n  InterfaceType,\n  IntersectionType,\n  KeyofType,\n  LiteralType,\n  Mixed,\n  NullType,\n  NumberType,\n  PartialType,\n  Props,\n  ReadonlyArrayType,\n  ReadonlyType,\n  RefinementType,\n  StringType,\n  TupleType,\n  TypeC,\n  UndefinedType,\n  UnionType,\n  UnknownType,\n  VoidType,\n} from 'io-ts'\nimport tcomb from 'tcomb'\nimport { buildObject } from './common'\nimport { EnumType } from './enums'\nimport { ObjType } from './obj'\nimport { Literal } from './tcombRefinements'\n\nfunction rtFromObjectSpec<T extends Props>(\n  spec: TypeC<T>,\n  options: { readonly strict: boolean } = { strict: false },\n): tcomb.Struct<T> {\n  return tcomb.struct(buildObject(spec.props, rtFromSpec), {\n    name: spec.name,\n    strict: options.strict,\n  })\n}\n\nexport function rtFromSpec(\n  spec: Mixed,\n):\n  | tcomb.Irreducible<any>\n  | tcomb.Enums\n  | tcomb.Struct<any>\n  | tcomb.Tuple<any>\n  | tcomb.Maybe<any> {\n  if (spec.name === 'Int') {\n    return tcomb.Integer\n  }\n\n  if (spec instanceof NumberType) {\n    return tcomb.Number\n  }\n\n  if (spec instanceof StringType) {\n    return tcomb.String\n  }\n\n  if (spec instanceof LiteralType) {\n    return Literal(spec.value)\n  }\n\n  if (spec instanceof BooleanType) {\n    return tcomb.Boolean\n  }\n\n  if (spec.name === 'Date') {\n    return tcomb.Date\n  }\n\n  if (spec.name === 'DateFromISOString') {\n    return tcomb.Date\n  }\n\n  if (spec instanceof KeyofType) {\n    return tcomb.enums(spec.keys)\n  }\n\n  if (spec instanceof EnumType) {\n    return tcomb.enums.of(spec.keys)\n  }\n\n  // TODO: literal type?\n\n  if (\n    spec instanceof NullType ||\n    spec instanceof UndefinedType ||\n    spec instanceof VoidType\n  ) {\n    return tcomb.Nil\n  }\n\n  if (spec instanceof UnknownType) {\n    return tcomb.Any // this looks wrong, but is it?\n  }\n\n  if (spec instanceof ObjType) {\n    // @TODO: strict: true if Exact ObjType\n    tcomb.struct(buildObject(spec.props, rtFromSpec), { name: spec.name })\n  }\n\n  if (spec instanceof InterfaceType) {\n    return rtFromObjectSpec(spec)\n  }\n\n  if (spec instanceof PartialType) {\n    return tcomb.struct(\n      buildObject(spec.props, p => tcomb.maybe(rtFromSpec(p))),\n      { name: spec.name },\n    )\n  }\n\n  if (spec instanceof ReadonlyType) {\n    return rtFromSpec(spec.type)\n  }\n\n  if (spec instanceof ExactType) {\n    return rtFromObjectSpec(spec.type, { strict: true })\n  }\n\n  if (spec instanceof RefinementType) {\n    return tcomb.refinement(rtFromSpec(spec.type), spec.predicate)\n  }\n\n  if (spec instanceof ArrayType || spec instanceof ReadonlyArrayType) {\n    return tcomb.list(rtFromSpec(spec.type))\n  }\n\n  if (spec instanceof AnyArrayType) {\n    return tcomb.list(tcomb.Any)\n  }\n\n  if (spec instanceof IntersectionType) {\n    return tcomb.intersection(spec.types.map(rtFromSpec))\n  }\n\n  if (spec instanceof UnionType) {\n    return tcomb.union(spec.types.map(rtFromSpec))\n  }\n\n  if (spec instanceof TupleType) {\n    return tcomb.tuple(spec.types.map(rtFromSpec))\n  }\n\n  throw new Error(`Unsupported ${spec.name}`)\n}\n","export function capitalize(arg: string): string {\n  return arg.length === 0 ? '' : arg[0].toUpperCase() + arg.slice(1)\n}\n\nexport function toLower(arg: string, delimiter?: string): string {\n  if (arg.length === 0) {\n    return ''\n  }\n\n  let result: string = arg[0].toLowerCase()\n\n  // tslint:disable-next-line: no-loop-statement\n  for (let i: number = 1; i < arg.length; i += 1) {\n    if (arg[i] === arg[i].toUpperCase()) {\n      result += `${delimiter}${arg[i].toLowerCase()}`\n    } else {\n      result += arg[i]\n    }\n  }\n\n  return result\n}\n\nexport function camelCaseToHyphenated(arg: string): string {\n  return toLower(arg, '-')\n}\n\nexport function camelCaseToSpaced(arg: string): string {\n  return toLower(arg, ' ')\n}\n\nexport const camelCaseToPhrase: (arg: string) => string = arg =>\n  capitalize(toLower(arg, ' '))\n\nexport function chop(arg: string, delimiter: string = '/'): string {\n  return arg.length === 0\n    ? ''\n    : arg.endsWith(delimiter)\n    ? arg.slice(0, arg.length - 1)\n    : arg\n}\n\nexport function extractSegment(\n  arg: string,\n  fromIndex: number,\n  upto: string,\n): string {\n  if (arg.length === 0) {\n    return ''\n  }\n\n  const p: string = arg.slice(fromIndex)\n  const s: number = p.indexOf(upto)\n\n  return s === -1 ? p.trim() : p.slice(0, s).trim()\n}\n\nexport function capitalizeAll(\n  str: string,\n  delimiter: string = ' ',\n  joinDelimiter: string = ' ',\n): string {\n  return str\n    .split(delimiter)\n    .map(capitalize)\n    .join(joinDelimiter)\n}\n","import { brand, BrandC, Branded } from 'io-ts'\nimport { date, DateC } from 'io-ts-types/lib/date'\n\nexport interface TimeOnlyBrand {\n  readonly TimeOnly: unique symbol\n}\n\nexport const TimeOnly: BrandC<DateC, TimeOnlyBrand> = brand(\n  date,\n  (n): n is Branded<Date, TimeOnlyBrand> => date.is(n),\n  'TimeOnly',\n)\n\nexport type TimeOnly = Branded<Date, TimeOnlyBrand>\n","import {\n  boolean,\n  BooleanC,\n  BrandC,\n  Int,\n  IntBrand,\n  Mixed,\n  number,\n  NumberC,\n  Props,\n  string,\n  StringC,\n} from 'io-ts'\nimport { PickByValue } from 'utility-types'\nimport { buildObject, omit, pick } from './common'\nimport {\n  exactObj,\n  ExactObjC,\n  obj,\n  ObjC,\n  ObjOptOf,\n  ObjPropsOf,\n  ObjReqOf,\n  opt,\n  req,\n} from './obj'\n\nexport function objPick<\n  Opt extends Props,\n  Req extends Props,\n  K extends keyof ObjC<Opt, Req>['props']\n>(\n  spec: ObjC<Opt, Req>,\n  keys: readonly K[],\n  name?: string,\n): ObjC<\n  Pick<Opt, Extract<keyof ObjOptOf<Opt, Req>, K>>,\n  Pick<Req, Extract<keyof ObjReqOf<Opt, Req>, K>>\n> {\n  return obj(\n    pick(spec.optional, keys as any[]),\n    pick(spec.required, keys as any[]),\n    name,\n  )\n}\n\nexport function objOmit<\n  Opt extends Props,\n  Req extends Props,\n  K extends keyof ObjPropsOf<Opt, Req>\n>(\n  spec: ObjC<Opt, Req>,\n  keys: readonly K[],\n  name?: string,\n): ObjC<\n  Omit<Opt, Extract<keyof ObjC<Opt, Req>['optional'], K>>,\n  Omit<Req, Extract<keyof ObjC<Opt, Req>['required'], K>>\n> {\n  return obj(\n    omit(spec.optional, keys as any) as any,\n    omit(spec.required, keys as any) as any,\n    name,\n  )\n}\n\n// export function propsPick<\n//   Opt extends Props,\n//   Req extends Props,\n//   KP extends keyof Opt,\n//   KR extends keyof Req\n// >(\n//   { optional, required }: ObjC<Opt, Req>,\n//   optKeys: readonly KP[] = [],\n//   reqKeys: readonly KR[] = [],\n//   name?: string,\n// ): ObjC<Pick<Opt, KP>, Pick<Req, KR>> {\n//   return obj(pick(optional, optKeys), pick(required, reqKeys), name)\n// }\n\n// export function propsOmit<\n//   Opt extends Props,\n//   Req extends Props,\n//   KP extends keyof Opt,\n//   KR extends keyof Req\n// >(\n//   { optional, required }: ObjC<Opt, Req>,\n//   optKeys: readonly KP[] = [],\n//   reqKeys: readonly KR[] = [],\n//   name?: string,\n// ): ObjC<Omit<Opt, KP>, Omit<Req, KR>> {\n//   return obj(omit(optional, optKeys), omit(required, reqKeys), name)\n// }\n\nexport function objCombine<\n  Opt extends Props,\n  Req extends Props,\n  Opt2 extends Props,\n  Req2 extends Props\n>(\n  p: ObjC<Opt, Req>,\n  p2: ObjC<Opt2, Req2>,\n  name?: string,\n): ObjC<Opt & Opt2, Req & Req2> {\n  return obj(\n    { ...p.optional, ...p2.optional },\n    { ...p.required, ...p2.required },\n    name,\n  )\n}\n\nexport function toOpt<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n  name?: string,\n): ObjC<Req & Opt, {}> {\n  return opt(spec.props, name)\n}\n\nexport function toReq<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n  name?: string,\n): ObjC<{}, Req & Opt> {\n  return req(spec.props, name)\n}\n\nexport function toExact<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n  name?: string,\n): ExactObjC<Opt, Req> {\n  return exactObj(spec.optional, spec.required, name)\n}\n\n// export function pickByValue\n\nexport type ObjCPickBy<Opt extends Props, Req extends Props, ValueType> = ObjC<\n  PickByValue<ObjC<Opt, Req>['required'], ValueType>,\n  PickByValue<ObjC<Opt, Req>['optional'], ValueType>\n>\n\nexport function pickBy<\n  Opt extends Props,\n  Req extends Props,\n  Picks extends Mixed[]\n>(\n  spec: ObjC<Opt, Req>,\n  ...picks: Picks\n): ObjCPickBy<Opt, Req, typeof picks[number]> {\n  function isSpec(\n    names: readonly string[],\n  ): (spec: Mixed) => Mixed | undefined {\n    return spec => (names.includes(spec.name) ? spec : undefined)\n  }\n\n  return obj(\n    buildObject(spec.required, isSpec(picks.map(s => s.name))),\n    buildObject(spec.optional, isSpec(picks.map(s => s.name))),\n  ) as any\n}\n\nexport function pickStrings<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<Opt, Req, StringC> {\n  return pickBy(spec, string)\n}\n\nexport function pickNumbers<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<Opt, Req, NumberC> {\n  return pickBy(spec, number)\n}\n\nexport function pickInts<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<Opt, Req, BrandC<NumberC, IntBrand>> {\n  return pickBy(spec, Int)\n}\n\nexport function pickNumeric<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<Opt, Req, NumberC | BrandC<NumberC, IntBrand>> {\n  return pickBy(spec, number, Int)\n}\n\nexport function pickStringly<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<\n  Opt,\n  Req,\n  NumberC | BrandC<NumberC, IntBrand> | StringC | BooleanC\n> {\n  return pickBy(spec, Int, number, string, boolean)\n}\n","import {\n  AnyArrayType,\n  ArrayType,\n  BooleanType,\n  ExactType,\n  InterfaceType,\n  IntersectionType,\n  KeyofType,\n  LiteralType,\n  Mixed,\n  NullType,\n  NumberType,\n  PartialType,\n  ReadonlyArrayType,\n  ReadonlyType,\n  RefinementType,\n  StringType,\n  TupleType,\n  TypeOf,\n  UndefinedType,\n  UnionType,\n  UnknownType,\n  VoidType,\n} from 'io-ts'\nimport { buildObject, keys, today } from './common'\nimport { EnumType } from './enums'\nimport { ObjType } from './obj'\nexport function empty<T extends Mixed>(spec: T): TypeOf<T> {\n  if (spec.name === 'Int' || spec instanceof NumberType) {\n    return 0\n  }\n\n  if (spec instanceof StringType) {\n    return ''\n  }\n\n  if (spec instanceof BooleanType) {\n    return false\n  }\n\n  if (spec.name === 'Date') {\n    return today()\n  }\n\n  if (spec.name === 'DateFromISOString') {\n    return today()\n  }\n\n  if (spec instanceof KeyofType) {\n    return keys(spec.keys)[0]\n  }\n\n  if (spec instanceof EnumType) {\n    return spec.keys[0]\n  }\n\n  if (spec instanceof LiteralType) {\n    return spec.value\n  }\n\n  if (spec instanceof NullType) {\n    // tslint:disable-next-line: no-null-keyword\n    return null\n  }\n\n  if (spec instanceof UndefinedType || spec instanceof VoidType) {\n    return undefined\n  }\n\n  if (spec instanceof UnknownType) {\n    return ''\n  }\n\n  if (\n    spec instanceof InterfaceType ||\n    spec instanceof PartialType ||\n    spec instanceof ObjType\n  ) {\n    return buildObject(spec.props, empty)\n  }\n\n  if (\n    spec instanceof ExactType ||\n    spec instanceof ReadonlyType ||\n    spec instanceof RefinementType\n  ) {\n    return empty(spec.type)\n  }\n\n  if (\n    spec instanceof ReadonlyArrayType ||\n    spec instanceof ArrayType ||\n    spec instanceof AnyArrayType\n  ) {\n    return []\n  }\n\n  if (spec instanceof IntersectionType) {\n    return spec.types\n      .map(empty)\n      .reduce((acc: any, x: any) => ({ ...acc, ...x }))\n  }\n\n  if (spec instanceof UnionType) {\n    return empty(spec.types[0])\n  }\n\n  if (spec instanceof TupleType) {\n    return spec.types.map(empty)\n  }\n\n  throw new Error(`Unsupported type: ${spec.name}`)\n}\n","import { Constructor, Irreducible } from 'tcomb'\nimport { verify } from './assertions'\nimport { buildObject, keys, nop } from './common'\nimport {\n  isDict,\n  isEnums,\n  isInteger,\n  isInterface,\n  isIntersection,\n  isIrreducible,\n  isList,\n  isMaybe,\n  isStruct,\n  isTuple,\n  isType,\n  isUnion,\n} from './isTcomb'\n\nfunction emptyFromIrreducible(rt: Irreducible<any>): any {\n  verify(rt.meta.kind === 'irreducible', 'rt must be irreducible')\n\n  switch (rt.meta.name) {\n    case 'Number':\n      return 0\n\n    case 'Any':\n    case 'String':\n      return ''\n\n    case 'Boolean':\n      return false\n\n    case 'Date':\n      return new Date()\n\n    case 'Function':\n      return nop\n\n    case 'RegExp':\n      return /(?:)/\n\n    case 'Nil':\n      return undefined\n\n    case 'Error':\n      return new Error('empty error')\n\n    case 'Object':\n      return {}\n\n    case 'Array':\n      return []\n\n    default:\n      throw new Error(\n        `Unsupported tcomb type: ${rt.meta.kind}: ${rt.meta.name}`,\n      )\n  }\n}\n\nexport function emptyFromRT(rt: Constructor<any>): any {\n  if (!isType(rt)) {\n    throw new Error('I have no idea about what do with a function')\n  }\n\n  verify(rt && rt.meta && rt.meta.kind)\n\n  if (isInteger(rt)) {\n    return 0\n  }\n\n  if (isStruct(rt)) {\n    return rt(buildObject(rt.meta.props, emptyFromRT))\n  }\n\n  if (isInterface(rt)) {\n    return buildObject(rt.meta.props, emptyFromRT)\n  }\n\n  if (isList(rt)) {\n    return []\n  }\n\n  if (isDict(rt)) {\n    return {}\n  }\n\n  if (isIntersection(rt)) {\n    return rt.meta.types.map(emptyFromRT).reduce((acc, x) => ({ ...acc, ...x }))\n  }\n\n  if (isMaybe(rt)) {\n    return emptyFromRT(rt.meta.type) // may be return undefined?\n  }\n\n  if (isUnion(rt)) {\n    return emptyFromRT(rt.meta.types[0])\n  }\n\n  if (isEnums(rt)) {\n    return keys(rt.meta.map)[0]\n  }\n\n  // case 'subtype':\n  //   return empty(rt.meta.type) // this is hard, how to satisfy predicate?\n\n  // case 'func':\n  //   return nop // need function returning value of correct type\n\n  if (isTuple(rt)) {\n    return rt.meta.types.map(emptyFromRT)\n  }\n\n  if (isIrreducible(rt)) {\n    return emptyFromIrreducible(rt)\n  }\n\n  throw new Error(`Unsupported tcomb type: ${rt.meta.kind}`)\n}\n","import tcomb from 'tcomb'\nimport { buildObject } from './common'\n\nfunction rtFromPrimitiveValue(value: unknown): tcomb.Irreducible<any> {\n  if (tcomb.Integer.is(value)) {\n    return tcomb.Integer\n  }\n  if (tcomb.Number.is(value)) {\n    return tcomb.Number\n  }\n  if (tcomb.String.is(value)) {\n    return tcomb.String\n  }\n  if (tcomb.Boolean.is(value)) {\n    return tcomb.Boolean\n  }\n  if (tcomb.RegExp.is(value)) {\n    return tcomb.RegExp\n  }\n  if (tcomb.Function.is(value)) {\n    return tcomb.Function\n  }\n  if (tcomb.Error.is(value)) {\n    return tcomb.Error\n  }\n  if (tcomb.Nil.is(value)) {\n    return tcomb.Nil\n  }\n\n  throw new Error(`Unsupported #{value}`)\n}\n\nfunction rtFromArrayValue<V, T extends ReadonlyArray<V>>(\n  value: T,\n): tcomb.List<ReadonlyArray<tcomb.Type<any>>> | tcomb.List<any> {\n  return value[0] !== undefined\n    ? tcomb.list(rtFromValue(value[0]))\n    : tcomb.list(tcomb.Any)\n}\n\nfunction rtFromObjectValue<T extends {}>(value: T): tcomb.Struct<T> {\n  return tcomb.struct(buildObject(value, rtFromValue))\n}\n\nexport function rtFromValue<T>(value: T): tcomb.Type<any> {\n  if (tcomb.Array.is(value)) {\n    return rtFromArrayValue(value)\n  }\n\n  if (tcomb.Object.is(value)) {\n    return rtFromObjectValue(value)\n  }\n\n  return rtFromPrimitiveValue(value)\n}\n","import { BooleanFromString } from 'io-ts-types/lib/BooleanFromString'\nimport { DateFromISOString } from 'io-ts-types/lib/DateFromISOString'\nimport { IntFromString } from 'io-ts-types/lib/IntFromString'\nimport { NumberFromString } from 'io-ts-types/lib/NumberFromString'\nimport { cast } from './iotsUtils'\n\nexport function toInt(from: string): number {\n  return cast(IntFromString, from)\n}\n\nexport function toBoolean(from: string): boolean {\n  return cast(BooleanFromString, from)\n}\n\nexport function toNumber(from: string): number {\n  return cast(NumberFromString, from)\n}\nexport function toDate(from: string): Date {\n  return cast(DateFromISOString, from)\n}\n"],"names":["warn","condition","message","text","console","Error","x","fatal","verify","nop","rangeInternal","start","stop","step","result","i","push","repeatedly","n","f","buildArray","keys","obj","Object","buildObject","k","v","undefined","today","startOfDay","Date","ISODate","union","date","DateFromISOString","pick","ks","includes","omit","rejected","decoded","Promise","reject","string","is","PathReporter","report","join","cast","spec","args","decode","isRight","right","verifyCast","assertCast","debugCast","lit","literal","tupleChecked","argSpecs","resultSpec","tupleCheckedAsync","DateOnly","brand","EnumType","name","validate","encode","Type","enums","u","c","success","failure","identity","ObjType","optional","required","props","intersection","readonly","partial","type","newObj","exactObj","exact","newExactObj","req","opt","isType","t","isStruct","meta","kind","isInterface","isIntersection","isMaybe","isUnion","isEnums","isTuple","isList","isDict","isIrreducible","isInteger","emptyFromValue","value","Array","UnknownRecord","emptyFromObjectValue","number","boolean","FnType","_this","id","inner","IntID","Int","StrID","Positive","refinement","Number","Negative","PositiveInt","Integer","NegativeInt","rEmail","rUrl","Email","String","s","test","Url","Lower","toLowerCase","Upper","toUpperCase","Literal","rtFromObjectSpec","options","strict","tcomb","struct","rtFromSpec","NumberType","StringType","LiteralType","BooleanType","Boolean","KeyofType","of","NullType","UndefinedType","VoidType","Nil","UnknownType","Any","InterfaceType","PartialType","p","maybe","ReadonlyType","ExactType","RefinementType","predicate","ArrayType","ReadonlyArrayType","list","AnyArrayType","IntersectionType","types","map","UnionType","TupleType","tuple","capitalize","arg","length","slice","toLower","delimiter","TimeOnly","pickBy","isSpec","names","picks","max","arr","min","len","d","compareAsc","str","joinDelimiter","split","codecs","endsWith","empty","reduce","acc","emptyFromRT","rt","emptyFromIrreducible","fromIndex","upto","indexOf","trim","prop","interval","resolve","setInterval","JSON","stringify","p2","rtFromValue","rtFromArrayValue","rtFromObjectValue","RegExp","Function","rtFromPrimitiveValue","delay","setTimeout","from","BooleanFromString","IntFromString","NumberFromString","either"],"mappings":"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"}