{"version":3,"file":"technoidentity-utils.cjs.development.js","sources":["../src/assertions.ts","../src/common.ts","../src/iotsUtils.ts","../src/checked.ts","../src/coercions.ts","../src/dateOnly.ts","../src/enums.ts","../src/obj.ts","../src/empty.ts","../src/isTcomb.ts","../src/emptyFromRT.ts","../src/emptyFromValue.ts","../src/fn.ts","../src/id.ts","../src/tcombRefinements.ts","../src/rtFromSpec.ts","../src/rtFromValue.ts","../src/stringUtils.ts","../src/timeOnly.ts","../src/objUtils.ts"],"sourcesContent":["// copied from tiny-warning package\nexport function warn(condition: unknown, message: string): void {\n  if (condition) {\n    return\n  }\n\n  const text: string = `Warning: ${message}`\n\n  // tslint:disable-next-line no-console\n  console.warn(text)\n\n  // Throwing an error and catching it immediately to improve debugging.\n  // A consumer can use 'pause on caught exceptions'\n  // https://github.com/facebook/react/issues/4216\n  try {\n    throw Error(text)\n    // tslint:disable-next-line no-empty\n  } catch (x) {}\n}\n\nexport function debug(condition: unknown, message: string): void {\n  if (process.env.NODE_ENV === 'development') {\n    warn(condition, message)\n  }\n}\n\nexport function fatal(message?: string): never {\n  if (process.env.NODE_ENV === 'production') {\n    // In production we strip the message but still throw\n    throw new Error('Invariant failed')\n  } else {\n    // When not in production we allow the message to pass through\n    // *This block will be removed in production builds*\n    throw new Error(`Invariant failed: ${message || ''}`)\n  }\n}\n\nexport function error(message?: string): void {\n  if (process.env.NODE_ENV === 'development') {\n    fatal(message)\n  }\n}\n\n// copied from tiny-invariant package\nexport function verify(condition: unknown, message?: string): void {\n  if (!condition) {\n    fatal(message)\n  }\n}\n\nexport function assert(condition: unknown, message?: string): void {\n  if (process.env.NODE_ENV === 'development') {\n    verify(condition, message)\n  }\n}\n","import { startOfDay } from 'date-fns'\nimport { TypeOf, union } from 'io-ts'\nimport { date } from 'io-ts-types/lib/date'\nimport { DateFromISOString } from 'io-ts-types/lib/DateFromISOString'\nimport { NonUndefined } from 'utility-types'\nimport { assert } from './assertions'\n\n// tslint:disable no-loop-statement no-array-mutation no-object-mutation no-null-keyword\n\nexport function freeze<T>(v: T): Readonly<T> {\n  return process.env.NODE_ENV !== 'production' ? Object.freeze(v) : v\n}\n\nexport function jsonStringify(obj: object): string {\n  return JSON.stringify(obj, null, 2)\n}\n\nexport function nop(..._: any[]): any {\n  return undefined\n}\n\nfunction rangeInternal(\n  start: number,\n  stop: number,\n  step: number = 1,\n): ReadonlyArray<number> {\n  assert(step > 0)\n\n  const result: number[] = []\n  for (let i: number = start; i < stop; i += step) {\n    result.push(i)\n  }\n  return result\n}\n\nexport function range(\n  start: number,\n  stop?: number,\n  step?: number,\n): ReadonlyArray<number> {\n  return stop ? rangeInternal(start, stop, step) : rangeInternal(0, start)\n}\n\nexport function repeatedly<T>(\n  n: number,\n  f: (index: number) => T,\n): ReadonlyArray<T> {\n  const result: T[] = []\n  for (let i: number = 0; i < n; i++) {\n    result.push(f(i))\n  }\n  return result\n}\n\nexport const buildArray: typeof repeatedly = repeatedly\n\nexport function keys<T extends Object>(obj: T): ReadonlyArray<keyof T> {\n  return Object.keys(obj) as ReadonlyArray<keyof T>\n}\n\nexport function buildObject<T extends {}, R>(\n  obj: T,\n  f: (value: T[typeof key], key: keyof T) => R,\n): Record<keyof T, NonUndefined<R>> {\n  const result: any = {}\n  for (const k of keys(obj)) {\n    const v: any = f(obj[k], k)\n    if (v !== undefined) {\n      result[k] = v\n    }\n  }\n  return result\n}\n\nexport function today(): Date {\n  return startOfDay(new Date())\n}\n\nexport async function timeout<T>(delay: number, f: () => T = nop): Promise<T> {\n  return new Promise(resolve => setTimeout(() => resolve(f()), delay))\n}\n\nexport async function interval<T>(\n  interval: number,\n  f: () => T = nop,\n): Promise<T> {\n  return new Promise(resolve => setInterval(() => resolve(f()), interval))\n}\n\n// tslint:disable-next-line: typedef\nexport const ISODate = union([date, DateFromISOString])\n\nexport type ISODate = TypeOf<typeof ISODate>\n\nexport function pick<T extends {}, K extends keyof T>(\n  obj: T,\n  ks: ReadonlyArray<K>,\n): Pick<T, K> {\n  const result: any = {}\n\n  for (const k of keys(obj)) {\n    if (ks.includes(k as K)) {\n      result[k] = obj[k]\n    }\n  }\n\n  return result\n}\n\nexport function omit<T extends {}, K extends keyof T>(\n  obj: T,\n  ks: ReadonlyArray<K>,\n): Omit<T, K> {\n  const result: any = {}\n\n  for (const k of keys(obj)) {\n    if (!ks.includes(k as K)) {\n      result[k] = obj[k]\n    }\n  }\n\n  return result\n}\n","import { Either, isRight } from 'fp-ts/lib/Either'\nimport {\n  Errors,\n  ExactType,\n  InterfaceType,\n  IntersectionType,\n  literal,\n  PartialType,\n  Props,\n  ReadonlyType,\n  string,\n  Type,\n} from 'io-ts'\nimport { PathReporter } from 'io-ts/lib/PathReporter'\nimport { assert, fatal } from './assertions'\nimport { omit, pick } from './common'\nimport { ObjType } from './obj'\n// tslint:disable readonly-array array-type readonly-keyword\n\nexport function cast<A, O, I>(spec: Type<A, O, I>, args: I): A {\n  const decoded: Either<Errors, A> = spec.decode(args)\n  return isRight(decoded)\n    ? decoded.right\n    : fatal(PathReporter.report(decoded).join('\\n'))\n}\n\nexport const verifyCast: typeof cast = cast\n\nexport function assertCast<A, O, I>(\n  spec: Type<A, O, I>,\n  args: I,\n): A | undefined {\n  const decoded: Either<Errors, A> = spec.decode(args)\n  assert(spec.is(args), PathReporter.report(decoded).join('\\n'))\n  return isRight(decoded) ? decoded.right : undefined\n}\n\nexport const debugCast: typeof assertCast = assertCast\n\nexport async function rejected<T>(\n  decoded: Either<Errors, T> | string,\n): Promise<T> {\n  return Promise.reject(\n    new Error(\n      string.is(decoded) ? decoded : PathReporter.report(decoded).join('\\n'),\n    ),\n  )\n}\n\nexport async function toPromise<T>(either: Either<Errors, T>): Promise<T> {\n  return isRight(either) ? either.right : rejected(either)\n}\n\n// export function opt<P extends Props>(\n//   props: P,\n//   name?: string,\n// ): ReadonlyC<PartialC<P>> {\n//   return readonly(partial(props), name)\n// }\n\n// export function req<P extends Props>(\n//   props: P,\n//   name?: string,\n// ): ReadonlyC<TypeC<P>> {\n//   return readonly(type(props), name)\n// }\n\n// export function props<O extends Props, R extends Props>(\n//   optional: O,\n//   required: R,\n//   name?: string,\n// ): IntersectionC<[ReadonlyC<PartialC<O>>, ReadonlyC<TypeC<R>>]> {\n//   return intersection(\n//     [readonly(partial(optional)), readonly(type(required))],\n//     name,\n//   )\n// }\n\nexport const lit: typeof literal = literal\n\nexport interface GotPropsIntersection\n  extends IntersectionType<[GotProps, GotProps, ...Array<GotProps>]> {}\n\nexport interface GotPropsReadonly extends ReadonlyType<GotProps> {}\n\nexport type GotPropsOnType = GotPropsReadonly | ExactType<any>\n\nexport type GotPropsOnProps =\n  | InterfaceType<any>\n  | PartialType<any>\n  | ObjType<any, any, any, any>\n\nexport type GotProps = GotPropsIntersection | GotPropsOnProps | GotPropsOnType\n\n// export function getProps<T extends Mixed>(codec: T & GotProps): Props {\n//   switch (codec._tag) {\n//     case 'ReadonlyType':\n//     case 'ExactType':\n//       return getProps(codec.type)\n//     case 'InterfaceType':\n//     case 'ObjType':\n//     case 'PartialType':\n//       return codec.props\n//     case 'IntersectionType':\n//       return codec.types.reduce<Props>(\n//         (props, type) => ({ ...props, ...getProps(type as any) }),\n//         {},\n//       )\n//   }\n// }\n\n// export function getProp<T extends Mixed>(\n//   codec: T & GotProps,\n//   key: string,\n// ): Mixed | undefined {\n//   switch (codec._tag) {\n//     case 'ReadonlyType':\n//     case 'ExactType':\n//       return getProp(codec.type, key)\n//     case 'InterfaceType':\n//     case 'ObjType':\n//     case 'PartialType':\n//       return codec.props[key]\n//     case 'IntersectionType':\n//       for (const t of codec.types) {\n//         const result: Mixed | undefined = getProp(t as any, key)\n//         if (result !== undefined) {\n//           return result\n//         }\n//       }\n//       return undefined\n//   }\n// }\n\nexport function pickProps<T extends Props, K extends keyof T>(\n  props: T,\n  keys: ReadonlyArray<K>,\n): Pick<T, K> {\n  return pick(props, keys)\n}\n\nexport function omitProps<T extends Props, K extends keyof T>(\n  props: T,\n  keys: ReadonlyArray<K>,\n): Omit<T, K> {\n  return omit(props, keys)\n}\n","import { Mixed, tuple, TupleC, TypeOf } from 'io-ts'\nimport { cast } from './iotsUtils'\n\n// tslint:disable readonly-array\n\n// TODO: revisit replacing tuple once ts 3.7 releases with circular references support\n\nexport function tupleChecked<\n  T extends [Mixed, ...Mixed[]],\n  A extends TypeOf<TupleC<T>> & any[],\n  R extends Mixed\n>(argSpecs: TupleC<T>, resultSpec: R, f: (...args: A) => TypeOf<R>): typeof f {\n  return (...args) => {\n    cast(argSpecs, args)\n\n    return cast(resultSpec, f(...args))\n  }\n}\n\nexport function checked<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  D extends Mixed,\n  E extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C, D, E],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  D extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C, D],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked<A extends Mixed, B extends Mixed, R extends Mixed>(\n  codecs: [A, B],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked<A extends Mixed, R extends Mixed>(\n  codecs: [A],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => TypeOf<R>,\n): typeof f\n\nexport function checked(\n  codecs: any,\n  resultSpec: any,\n  f: (...args: any[]) => any,\n): typeof f {\n  return tupleChecked(tuple(codecs), resultSpec, f)\n}\n\nexport function tupleCheckedAsync<\n  T extends [Mixed, ...Mixed[]],\n  A extends TypeOf<TupleC<T>> & any[],\n  R extends Mixed\n>(\n  argSpecs: TupleC<T>,\n  resultSpec: R,\n  f: (...args: A) => Promise<TypeOf<typeof resultSpec>>,\n): typeof f {\n  return async (...args) => {\n    cast(argSpecs, args)\n\n    return cast(resultSpec, await f(...args))\n  }\n}\n\nexport function checkedAsync<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  D extends Mixed,\n  E extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C, D, E],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  D extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C, D],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync<\n  A extends Mixed,\n  B extends Mixed,\n  C extends Mixed,\n  R extends Mixed\n>(\n  codecs: [A, B, C],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync<A extends Mixed, B extends Mixed, R extends Mixed>(\n  codecs: [A, B],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync<A extends Mixed, R extends Mixed>(\n  codecs: [A],\n  resultSpec: R,\n  f: (...args: TypeOf<TupleC<typeof codecs>> & any[]) => Promise<TypeOf<R>>,\n): typeof f\n\nexport function checkedAsync(\n  codecs: any,\n  resultSpec: any,\n  f: (...args: any[]) => any,\n): typeof f {\n  return tupleCheckedAsync(tuple(codecs), resultSpec, f)\n}\n","import { BooleanFromString } from 'io-ts-types/lib/BooleanFromString'\nimport { DateFromISOString } from 'io-ts-types/lib/DateFromISOString'\nimport { IntFromString } from 'io-ts-types/lib/IntFromString'\nimport { NumberFromString } from 'io-ts-types/lib/NumberFromString'\nimport { cast } from './iotsUtils'\n\nexport function toInt(from: string): number {\n  return cast(IntFromString, from)\n}\n\nexport function toBoolean(from: string): boolean {\n  return cast(BooleanFromString, from)\n}\n\nexport function toNumber(from: string): number {\n  return cast(NumberFromString, from)\n}\nexport function toDate(from: string): Date {\n  return cast(DateFromISOString, from)\n}\n","import { brand, BrandC, Branded } from 'io-ts'\nimport { date, DateC } from 'io-ts-types/lib/date'\nexport interface DateOnlyBrand {\n  readonly DateOnly: unique symbol\n}\n\nexport const DateOnly: BrandC<DateC, DateOnlyBrand> = brand(\n  date,\n  (n): n is Branded<Date, DateOnlyBrand> => date.is(n),\n  'DateOnly',\n)\n\nexport type DateOnly = Branded<Date, DateOnlyBrand>\n","import { failure, identity, string, success, Type } from 'io-ts'\n\n// tslint:disable no-class readonly-array\n\nexport class EnumType<D extends string[], A> extends Type<A> {\n  readonly _tag: 'EnumType' = 'EnumType'\n\n  constructor(\n    readonly keys: D,\n    name: string,\n    is: EnumType<D, A>['is'],\n    validate: EnumType<D, A>['validate'],\n    encode: EnumType<D, A>['encode'],\n  ) {\n    super(name, is, validate, encode)\n  }\n}\n\nexport interface EnumC<D extends string[]> extends EnumType<D, D[number]> {}\n\nexport function enums<T extends string[]>(\n  name: string | undefined,\n  ...keys: T\n): EnumC<T> {\n  function is(u: unknown): u is T[number] {\n    return string.is(u) && keys.includes(u)\n  }\n\n  return new EnumType(\n    keys,\n    name || `Enum<${keys.join(' | ')}>`,\n    is,\n    (u, c) => (is(u) ? success(u) : failure(u, c)),\n    identity,\n  )\n}\n\nexport function enumerate<T extends string[]>(...keys: T): EnumC<T> {\n  return enums(undefined, ...keys)\n}\n","import {\n  exact,\n  ExactC,\n  intersection,\n  IntersectionC,\n  Mixed,\n  partial,\n  PartialC,\n  Props,\n  readonly,\n  ReadonlyC,\n  Type,\n  type,\n  TypeC,\n  TypeOf,\n} from 'io-ts'\n\n// tslint:disable no-class readonly-array\n\ntype OptSpec<Opt extends Props> = ReadonlyC<PartialC<Opt>>\ntype ReqSpec<Req extends Props> = ReadonlyC<TypeC<Req>>\ntype ObjSpec<Opt extends Props, Req extends Props> = IntersectionC<\n  [OptSpec<Opt>, ReqSpec<Req>]\n>\ntype ExactObjSpec<Opt extends Props, Req extends Props> = ExactC<\n  IntersectionC<[OptSpec<Opt>, ReqSpec<Req>]>\n>\n\n// type NoEmptyIntersect<Opt extends Props, Req extends Props> = {} extends Opt\n//   ? {} extends Req\n//     ? Opt\n//     : Req\n//   : Opt & Req\n\nexport class ObjType<\n  Opt extends Props,\n  Req extends Props,\n  A,\n  O = A,\n  I = unknown\n> extends Type<A, O, I> {\n  readonly _tag: 'ObjType' = 'ObjType'\n\n  constructor(\n    readonly optional: Opt,\n    readonly required: Req,\n    readonly props: Opt & Req,\n    spec: Type<A, O, I>,\n    name: string,\n  ) {\n    super(name, spec.is, spec.validate, spec.encode)\n  }\n}\n\nexport interface ObjC<Opt extends Props, Req extends Props>\n  extends ObjType<\n    Opt,\n    Req,\n    ObjSpec<Opt, Req>['_A'],\n    ObjSpec<Opt, Req>['_O'],\n    ObjSpec<Opt, Req>['_I']\n  > {}\n\nfunction newObj<Opt extends Props, Req extends Props>(\n  optional: Opt,\n  required: Req,\n  name?: string,\n): ObjC<Opt, Req> {\n  const spec: ObjSpec<Opt, Req> = intersection([\n    readonly(partial(optional)),\n    readonly(type(required)),\n  ])\n\n  return new ObjType(\n    optional,\n    required,\n    { ...optional, ...required },\n    spec,\n    name || spec.name,\n  )\n}\n\nexport type ObjPropsOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['props']\n\nexport type ObjReqOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['required']\n\nexport type ObjOptOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['optional']\n\nexport type ObjTypeOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['_A']\n\nexport type ObjOutPutOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['_O']\n\nexport type ObjInputOf<Opt extends Props, Req extends Props> = ObjC<\n  Opt,\n  Req\n>['_I']\n\nexport type AnyObj = Mixed & ObjC<any, any>\n\nexport interface ExactObjC<Opt extends Props, Req extends Props>\n  extends ObjType<\n    Opt,\n    Req,\n    ExactObjSpec<Opt, Req>['_A'],\n    ExactObjSpec<Opt, Req>['_O'],\n    ExactObjSpec<Opt, Req>['_I']\n  > {}\n\n// @TODO: need ability to distinguish ObjType from Exact ObjType\nfunction newExactObj<Opt extends Props, Req extends Props>(\n  optional: Opt,\n  required: Req,\n  name?: string,\n): ExactObjC<Opt, Req> {\n  const spec: ExactObjSpec<Opt, Req> = exact(\n    intersection([readonly(partial(optional)), readonly(type(required))]),\n  )\n  return new ObjType(\n    optional,\n    required,\n    { ...optional, ...required },\n    spec,\n    name || spec.name,\n  )\n}\n\nexport function obj<Opt extends Props, Req extends Props>(\n  optional: Opt,\n  required: Req,\n  name?: string,\n): ObjC<Opt, Req> {\n  return newObj(optional, required, name)\n}\n\nexport function exactObj<Opt extends Props, Req extends Props>(\n  optional: Opt,\n  required: Req,\n  name?: string,\n): ObjC<Opt, Req> {\n  return newExactObj(optional, required, name)\n}\n\nexport function req<Req extends Props>(\n  required: Req,\n  name?: string,\n): ObjC<{}, Req> {\n  return obj({}, required, name)\n}\n\nexport function opt<Opt extends Props>(\n  optional: Opt,\n  name?: string,\n): ObjC<Opt, {}> {\n  return obj(optional, {}, name)\n}\n\nexport function getProps<Spec extends AnyObj>(spec: AnyObj): Spec['props'] {\n  return spec.props\n}\n\nexport function getProp<Spec extends AnyObj, K extends keyof TypeOf<Spec>>(\n  spec: Spec,\n  prop: K,\n): Spec['props'][K] {\n  return spec.props[prop]\n}\n","import {\n  AnyArrayType,\n  ArrayType,\n  BooleanType,\n  ExactType,\n  InterfaceType,\n  IntersectionType,\n  KeyofType,\n  LiteralType,\n  Mixed,\n  NullType,\n  NumberType,\n  PartialType,\n  ReadonlyArrayType,\n  ReadonlyType,\n  RefinementType,\n  StringType,\n  TupleType,\n  TypeOf,\n  UndefinedType,\n  UnionType,\n  UnknownType,\n  VoidType,\n} from 'io-ts'\nimport { buildObject, keys, today } from './common'\nimport { EnumType } from './enums'\nimport { ObjType } from './obj'\nexport function empty<T extends Mixed>(spec: T): TypeOf<T> {\n  if (spec.name === 'Int' || spec instanceof NumberType) {\n    return 0\n  }\n\n  if (spec instanceof StringType) {\n    return ''\n  }\n\n  if (spec instanceof BooleanType) {\n    return false\n  }\n\n  if (spec.name === 'Date') {\n    return today()\n  }\n\n  if (spec.name === 'DateFromISOString') {\n    return today()\n  }\n\n  if (spec instanceof KeyofType) {\n    return keys(spec.keys)[0]\n  }\n\n  if (spec instanceof EnumType) {\n    return spec.keys[0]\n  }\n\n  if (spec instanceof LiteralType) {\n    return spec.value\n  }\n\n  if (spec instanceof NullType) {\n    // tslint:disable-next-line: no-null-keyword\n    return null\n  }\n\n  if (spec instanceof UndefinedType || spec instanceof VoidType) {\n    return undefined\n  }\n\n  if (spec instanceof UnknownType) {\n    return ''\n  }\n\n  if (\n    spec instanceof InterfaceType ||\n    spec instanceof PartialType ||\n    spec instanceof ObjType\n  ) {\n    return buildObject(spec.props, empty)\n  }\n\n  if (\n    spec instanceof ExactType ||\n    spec instanceof ReadonlyType ||\n    spec instanceof RefinementType\n  ) {\n    return empty(spec.type)\n  }\n\n  if (\n    spec instanceof ReadonlyArrayType ||\n    spec instanceof ArrayType ||\n    spec instanceof AnyArrayType\n  ) {\n    return []\n  }\n\n  if (spec instanceof IntersectionType) {\n    return spec.types\n      .map(empty)\n      .reduce((acc: any, x: any) => ({ ...acc, ...x }))\n  }\n\n  if (spec instanceof UnionType) {\n    return empty(spec.types[0])\n  }\n\n  if (spec instanceof TupleType) {\n    return spec.types.map(empty)\n  }\n\n  throw new Error(`Unsupported type: ${spec.name}`)\n}\n","import t, {\n  Constructor,\n  Dict,\n  Enums,\n  Interface,\n  Intersection,\n  Irreducible,\n  List,\n  Maybe,\n  Struct,\n  Tuple,\n  Type,\n  Union,\n} from 'tcomb'\n\nexport function isType<T>(spec: Constructor<T>): spec is Type<T> {\n  return t.isType(spec)\n}\n\nexport function isStruct<T>(spec: Type<T>): spec is Struct<T> {\n  return spec.meta.kind === 'struct'\n}\n\nexport function isInterface<T>(spec: Type<T>): spec is Interface<T> {\n  return spec.meta.kind === 'interface'\n}\n\nexport function isIntersection<T>(spec: Type<T>): spec is Intersection<T> {\n  return spec.meta.kind === 'intersection'\n}\n\nexport function isMaybe<T>(spec: Type<void | T>): spec is Maybe<T> {\n  return spec.meta.kind === 'maybe'\n}\n\nexport function isUnion<T>(spec: Type<T>): spec is Union<T> {\n  return spec.meta.kind === 'union'\n}\n\nexport function isEnums(spec: Type<string>): spec is Enums {\n  return spec.meta.kind === 'enums'\n}\n\nexport function isTuple<T>(spec: Type<T>): spec is Tuple<T> {\n  return spec.meta.kind === 'tuple'\n}\n\n// tslint:disable-next-line: readonly-array\nexport function isList<T>(spec: Type<T[]>): spec is List<T> {\n  return spec.meta.kind === 'list'\n}\n\n// tslint:disable-next-line: readonly-keyword\nexport function isDict<T>(spec: Type<{ [key: string]: T }>): spec is Dict<T> {\n  return spec.meta.kind === 'dict'\n}\n\nexport function isIrreducible<T>(spec: Type<T>): spec is Irreducible<T> {\n  return spec.meta.kind === 'irreducible'\n}\n\nexport function isInteger(spec: Type<any>): boolean {\n  return spec.meta.kind === 'subtype' && spec.meta.name === 'Integer'\n}\n","import { Constructor, Irreducible } from 'tcomb'\nimport { verify } from './assertions'\nimport { buildObject, keys, nop } from './common'\nimport {\n  isDict,\n  isEnums,\n  isInteger,\n  isInterface,\n  isIntersection,\n  isIrreducible,\n  isList,\n  isMaybe,\n  isStruct,\n  isTuple,\n  isType,\n  isUnion,\n} from './isTcomb'\n\nfunction emptyFromIrreducible(rt: Irreducible<any>): any {\n  verify(rt.meta.kind === 'irreducible', 'rt must be irreducible')\n\n  switch (rt.meta.name) {\n    case 'Number':\n      return 0\n\n    case 'Any':\n    case 'String':\n      return ''\n\n    case 'Boolean':\n      return false\n\n    case 'Date':\n      return new Date()\n\n    case 'Function':\n      return nop\n\n    case 'RegExp':\n      return /(?:)/\n\n    case 'Nil':\n      return undefined\n\n    case 'Error':\n      return new Error('empty error')\n\n    case 'Object':\n      return {}\n\n    case 'Array':\n      return []\n\n    default:\n      throw new Error(\n        `Unsupported tcomb type: ${rt.meta.kind}: ${rt.meta.name}`,\n      )\n  }\n}\n\nexport function emptyFromRT(rt: Constructor<any>): any {\n  if (!isType(rt)) {\n    throw new Error('I have no idea about what do with a function')\n  }\n\n  verify(rt && rt.meta && rt.meta.kind)\n\n  if (isInteger(rt)) {\n    return 0\n  }\n\n  if (isStruct(rt)) {\n    return rt(buildObject(rt.meta.props, emptyFromRT))\n  }\n\n  if (isInterface(rt)) {\n    return buildObject(rt.meta.props, emptyFromRT)\n  }\n\n  if (isList(rt)) {\n    return []\n  }\n\n  if (isDict(rt)) {\n    return {}\n  }\n\n  if (isIntersection(rt)) {\n    return rt.meta.types.map(emptyFromRT).reduce((acc, x) => ({ ...acc, ...x }))\n  }\n\n  if (isMaybe(rt)) {\n    return emptyFromRT(rt.meta.type) // may be return undefined?\n  }\n\n  if (isUnion(rt)) {\n    return emptyFromRT(rt.meta.types[0])\n  }\n\n  if (isEnums(rt)) {\n    return keys(rt.meta.map)[0]\n  }\n\n  // case 'subtype':\n  //   return empty(rt.meta.type) // this is hard, how to satisfy predicate?\n\n  // case 'func':\n  //   return nop // need function returning value of correct type\n\n  if (isTuple(rt)) {\n    return rt.meta.types.map(emptyFromRT)\n  }\n\n  if (isIrreducible(rt)) {\n    return emptyFromIrreducible(rt)\n  }\n\n  throw new Error(`Unsupported tcomb type: ${rt.meta.kind}`)\n}\n","import { Array, boolean, number, string, UnknownRecord } from 'io-ts'\nimport { date } from 'io-ts-types/lib/date'\nimport { warn } from './assertions'\nimport { buildObject, today } from './common'\n\nfunction emptyFromPrimitiveValue(v: unknown): any {\n  if (number.is(v)) {\n    return 0\n  }\n\n  if (string.is(v)) {\n    return ''\n  }\n\n  if (boolean.is(v)) {\n    return false\n  }\n\n  // tslint:disable-next-line: no-null-keyword\n  if (v == null) {\n    return v\n  }\n\n  if (date.is(v)) {\n    return today()\n  }\n\n  warn(false, `Unsupported value ${v}`)\n}\n\nfunction emptyFromObjectValue<T extends {}>(value: T): T {\n  return buildObject(value, emptyFromValue) as any\n}\n\nexport const emptyFromValue: <T>(value: T) => T = value => {\n  if (Array.is(value)) {\n    return []\n  }\n\n  if (UnknownRecord.is(value)) {\n    return emptyFromObjectValue(value)\n  }\n\n  return emptyFromPrimitiveValue(value)\n}\n","import { failure, identity, success, Type } from 'io-ts'\n\n// tslint:disable no-class no-this\n\nexport class FnType<F extends Function> extends Type<F> {\n  readonly _tag: 'FnType' = 'FnType'\n\n  constructor() {\n    super(\n      'FnType',\n      (u): u is F => typeof u === 'function',\n\n      (u, c) => (this.is(u) ? success(u) : failure(u, c)),\n      identity,\n    )\n  }\n}\n\nexport interface FnC<F extends Function> extends FnType<F> {}\n\nexport function fn<F extends Function>(): FnC<F> {\n  return new FnType<F>()\n}\n","import { brand, BrandC, Branded, Int, Mixed, string, TypeOf } from 'io-ts'\n\n// tslint:disable typedef\n\nexport function id<T extends Mixed>(\n  inner: T,\n  name?: string,\n): BrandC<T, { readonly id: symbol }> {\n  return brand(\n    inner,\n    (n): n is Branded<TypeOf<T>, { readonly id: unique symbol }> => inner.is(n),\n    name || `id<${inner.name}`,\n  )\n}\n\nexport const IntID = id(Int, 'IntID')\nexport type IntID = TypeOf<typeof IntID>\n\nexport const StrID = id(string, 'StrID')\nexport type StrID = TypeOf<typeof IntID>\n","import { compareAsc } from 'date-fns'\nimport t from 'tcomb'\n\n// tslint:disable typedef\n\nexport const Positive = t.refinement(t.Number, n => n >= 0, 'Positive')\nexport const Negative = t.refinement(t.Number, n => n <= 0, 'Negative')\nexport function Min(min: number) {\n  return t.refinement(t.Number, n => n >= min, 'Min')\n}\nexport function Max(max: number) {\n  return t.refinement(t.Number, n => n <= max, 'Max')\n}\n\nexport const PositiveInt = t.refinement(t.Integer, n => n >= 0, 'PositiveInt')\nexport const NegativeInt = t.refinement(t.Integer, n => n <= 0, 'NegativeInt')\nexport function MinInt(min: number) {\n  return t.refinement(t.Integer, n => n >= min, 'MinInt')\n}\nexport function MaxInt(max: number) {\n  return t.refinement(t.Integer, n => n <= max, 'MaxInt')\n}\n\n// eslint-disable-next-line\nconst rEmail: RegExp = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i\n// eslint-disable-next-line\nconst rUrl: RegExp = /^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i\n\nexport const Email = t.refinement(t.String, s => rEmail.test(s), 'Email')\nexport const Url = t.refinement(t.String, s => rUrl.test(s), 'Url')\nexport const Lower = t.refinement(\n  t.String,\n  s => s.toLowerCase() === s,\n  'Lowercase',\n)\nexport const Upper = t.refinement(\n  t.String,\n  s => s.toUpperCase() === s,\n  'Uppercase',\n)\nexport function Length(len: number) {\n  return t.refinement(t.String, s => s.length === len, 'StringLength')\n}\nexport function MinStringLength(min: number) {\n  return t.refinement(t.String, s => s.length >= min, 'MinStringLength')\n}\nexport function MaxStringLength(max: number) {\n  return t.refinement(t.String, s => s.length <= max, 'MaxStringLength')\n}\n\nexport function Literal(literal: string) {\n  return t.refinement(t.String, s => s === literal)\n}\n\nexport function MinDate(min: Date) {\n  return t.refinement(t.Date, d => compareAsc(min, d) <= 0, 'MinDate')\n}\nexport function MaxDate(max: Date) {\n  return t.refinement(t.Date, d => compareAsc(max, d) >= 0, 'MaxDate')\n}\n\nexport function ArrayMinLength(min: number) {\n  return t.refinement(t.Array, arr => arr.length >= min, 'ArrayMinLength')\n}\nexport function ArrayMaxLength(max: number) {\n  return t.refinement(t.Array, arr => arr.length <= max, 'ArrayMaxLength')\n}\n","import {\n  AnyArrayType,\n  ArrayType,\n  BooleanType,\n  ExactType,\n  InterfaceType,\n  IntersectionType,\n  KeyofType,\n  LiteralType,\n  Mixed,\n  NullType,\n  NumberType,\n  PartialType,\n  Props,\n  ReadonlyArrayType,\n  ReadonlyType,\n  RefinementType,\n  StringType,\n  TupleType,\n  TypeC,\n  UndefinedType,\n  UnionType,\n  UnknownType,\n  VoidType,\n} from 'io-ts'\nimport tcomb from 'tcomb'\nimport { buildObject } from './common'\nimport { EnumType } from './enums'\nimport { ObjType } from './obj'\nimport { Literal } from './tcombRefinements'\n\nfunction rtFromObjectSpec<T extends Props>(\n  spec: TypeC<T>,\n  options: { readonly strict: boolean } = { strict: false },\n): tcomb.Struct<T> {\n  return tcomb.struct(buildObject(spec.props, rtFromSpec), {\n    name: spec.name,\n    strict: options.strict,\n  })\n}\n\nexport function rtFromSpec(\n  spec: Mixed,\n):\n  | tcomb.Irreducible<any>\n  | tcomb.Enums\n  | tcomb.Struct<any>\n  | tcomb.Tuple<any>\n  | tcomb.Maybe<any> {\n  if (spec.name === 'Int') {\n    return tcomb.Integer\n  }\n\n  if (spec instanceof NumberType) {\n    return tcomb.Number\n  }\n\n  if (spec instanceof StringType) {\n    return tcomb.String\n  }\n\n  if (spec instanceof LiteralType) {\n    return Literal(spec.value)\n  }\n\n  if (spec instanceof BooleanType) {\n    return tcomb.Boolean\n  }\n\n  if (spec.name === 'Date') {\n    return tcomb.Date\n  }\n\n  if (spec.name === 'DateFromISOString') {\n    return tcomb.Date\n  }\n\n  if (spec instanceof KeyofType) {\n    return tcomb.enums(spec.keys)\n  }\n\n  if (spec instanceof EnumType) {\n    return tcomb.enums.of(spec.keys)\n  }\n\n  // TODO: literal type?\n\n  if (\n    spec instanceof NullType ||\n    spec instanceof UndefinedType ||\n    spec instanceof VoidType\n  ) {\n    return tcomb.Nil\n  }\n\n  if (spec instanceof UnknownType) {\n    return tcomb.Any // this looks wrong, but is it?\n  }\n\n  if (spec instanceof ObjType) {\n    // @TODO: strict: true if Exact ObjType\n    tcomb.struct(buildObject(spec.props, rtFromSpec), { name: spec.name })\n  }\n\n  if (spec instanceof InterfaceType) {\n    return rtFromObjectSpec(spec)\n  }\n\n  if (spec instanceof PartialType) {\n    return tcomb.struct(\n      buildObject(spec.props, p => tcomb.maybe(rtFromSpec(p))),\n      { name: spec.name },\n    )\n  }\n\n  if (spec instanceof ReadonlyType) {\n    return rtFromSpec(spec.type)\n  }\n\n  if (spec instanceof ExactType) {\n    return rtFromObjectSpec(spec.type, { strict: true })\n  }\n\n  if (spec instanceof RefinementType) {\n    return tcomb.refinement(rtFromSpec(spec.type), spec.predicate)\n  }\n\n  if (spec instanceof ArrayType || spec instanceof ReadonlyArrayType) {\n    return tcomb.list(rtFromSpec(spec.type))\n  }\n\n  if (spec instanceof AnyArrayType) {\n    return tcomb.list(tcomb.Any)\n  }\n\n  if (spec instanceof IntersectionType) {\n    return tcomb.intersection(spec.types.map(rtFromSpec))\n  }\n\n  if (spec instanceof UnionType) {\n    return tcomb.union(spec.types.map(rtFromSpec))\n  }\n\n  if (spec instanceof TupleType) {\n    return tcomb.tuple(spec.types.map(rtFromSpec))\n  }\n\n  throw new Error(`Unsupported ${spec.name}`)\n}\n","import tcomb from 'tcomb'\nimport { buildObject } from './common'\n\nfunction rtFromPrimitiveValue(value: unknown): tcomb.Irreducible<any> {\n  if (tcomb.Integer.is(value)) {\n    return tcomb.Integer\n  }\n  if (tcomb.Number.is(value)) {\n    return tcomb.Number\n  }\n  if (tcomb.String.is(value)) {\n    return tcomb.String\n  }\n  if (tcomb.Boolean.is(value)) {\n    return tcomb.Boolean\n  }\n  if (tcomb.RegExp.is(value)) {\n    return tcomb.RegExp\n  }\n  if (tcomb.Function.is(value)) {\n    return tcomb.Function\n  }\n  if (tcomb.Error.is(value)) {\n    return tcomb.Error\n  }\n  if (tcomb.Nil.is(value)) {\n    return tcomb.Nil\n  }\n\n  throw new Error(`Unsupported #{value}`)\n}\n\nfunction rtFromArrayValue<V, T extends ReadonlyArray<V>>(\n  value: T,\n): tcomb.List<ReadonlyArray<tcomb.Type<any>>> | tcomb.List<any> {\n  return value[0] !== undefined\n    ? tcomb.list(rtFromValue(value[0]))\n    : tcomb.list(tcomb.Any)\n}\n\nfunction rtFromObjectValue<T extends {}>(value: T): tcomb.Struct<T> {\n  return tcomb.struct(buildObject(value, rtFromValue))\n}\n\nexport function rtFromValue<T>(value: T): tcomb.Type<any> {\n  if (tcomb.Array.is(value)) {\n    return rtFromArrayValue(value)\n  }\n\n  if (tcomb.Object.is(value)) {\n    return rtFromObjectValue(value)\n  }\n\n  return rtFromPrimitiveValue(value)\n}\n","export function capitalize(arg: string): string {\n  return arg.length === 0 ? '' : arg[0].toUpperCase() + arg.slice(1)\n}\n\nexport function toLower(arg: string, delimiter?: string): string {\n  if (arg.length === 0) {\n    return ''\n  }\n\n  let result: string = arg[0].toLowerCase()\n\n  // tslint:disable-next-line: no-loop-statement\n  for (let i: number = 1; i < arg.length; i += 1) {\n    if (arg[i] === arg[i].toUpperCase()) {\n      result += `${delimiter}${arg[i].toLowerCase()}`\n    } else {\n      result += arg[i]\n    }\n  }\n\n  return result\n}\n\nexport function camelCaseToHyphenated(arg: string): string {\n  return toLower(arg, '-')\n}\n\nexport function camelCaseToSpaced(arg: string): string {\n  return toLower(arg, ' ')\n}\n\nexport const camelCaseToPhrase: (arg: string) => string = arg =>\n  capitalize(toLower(arg, ' '))\n\nexport function chop(arg: string, delimiter: string = '/'): string {\n  return arg.length === 0\n    ? ''\n    : arg.endsWith(delimiter)\n    ? arg.slice(0, arg.length - 1)\n    : arg\n}\n\nexport function extractSegment(\n  arg: string,\n  fromIndex: number,\n  upto: string,\n): string {\n  if (arg.length === 0) {\n    return ''\n  }\n\n  const p: string = arg.slice(fromIndex)\n  const s: number = p.indexOf(upto)\n\n  return s === -1 ? p.trim() : p.slice(0, s).trim()\n}\n\nexport function capitalizeAll(\n  str: string,\n  delimiter: string = ' ',\n  joinDelimiter: string = ' ',\n): string {\n  return str\n    .split(delimiter)\n    .map(capitalize)\n    .join(joinDelimiter)\n}\n","import { brand, BrandC, Branded } from 'io-ts'\nimport { date, DateC } from 'io-ts-types/lib/date'\n\nexport interface TimeOnlyBrand {\n  readonly TimeOnly: unique symbol\n}\n\nexport const TimeOnly: BrandC<DateC, TimeOnlyBrand> = brand(\n  date,\n  (n): n is Branded<Date, TimeOnlyBrand> => date.is(n),\n  'TimeOnly',\n)\n\nexport type TimeOnly = Branded<Date, TimeOnlyBrand>\n","import {\n  boolean,\n  BooleanC,\n  BrandC,\n  Int,\n  IntBrand,\n  Mixed,\n  number,\n  NumberC,\n  Props,\n  string,\n  StringC,\n} from 'io-ts'\nimport { PickByValue } from 'utility-types'\nimport { buildObject, omit, pick } from './common'\nimport {\n  exactObj,\n  ExactObjC,\n  obj,\n  ObjC,\n  ObjOptOf,\n  ObjPropsOf,\n  ObjReqOf,\n  opt,\n  req,\n} from './obj'\n\nexport function objPick<\n  Opt extends Props,\n  Req extends Props,\n  K extends keyof ObjC<Opt, Req>['props']\n>(\n  spec: ObjC<Opt, Req>,\n  keys: readonly K[],\n  name?: string,\n): ObjC<\n  Pick<Opt, Extract<keyof ObjOptOf<Opt, Req>, K>>,\n  Pick<Req, Extract<keyof ObjReqOf<Opt, Req>, K>>\n> {\n  return obj(\n    pick(spec.optional, keys as any[]),\n    pick(spec.required, keys as any[]),\n    name,\n  )\n}\n\nexport function objOmit<\n  Opt extends Props,\n  Req extends Props,\n  K extends keyof ObjPropsOf<Opt, Req>\n>(\n  spec: ObjC<Opt, Req>,\n  keys: readonly K[],\n  name?: string,\n): ObjC<\n  Omit<Opt, Extract<keyof ObjC<Opt, Req>['optional'], K>>,\n  Omit<Req, Extract<keyof ObjC<Opt, Req>['required'], K>>\n> {\n  return obj(\n    omit(spec.optional, keys as any) as any,\n    omit(spec.required, keys as any) as any,\n    name,\n  )\n}\n\n// export function propsPick<\n//   Opt extends Props,\n//   Req extends Props,\n//   KP extends keyof Opt,\n//   KR extends keyof Req\n// >(\n//   { optional, required }: ObjC<Opt, Req>,\n//   optKeys: readonly KP[] = [],\n//   reqKeys: readonly KR[] = [],\n//   name?: string,\n// ): ObjC<Pick<Opt, KP>, Pick<Req, KR>> {\n//   return obj(pick(optional, optKeys), pick(required, reqKeys), name)\n// }\n\n// export function propsOmit<\n//   Opt extends Props,\n//   Req extends Props,\n//   KP extends keyof Opt,\n//   KR extends keyof Req\n// >(\n//   { optional, required }: ObjC<Opt, Req>,\n//   optKeys: readonly KP[] = [],\n//   reqKeys: readonly KR[] = [],\n//   name?: string,\n// ): ObjC<Omit<Opt, KP>, Omit<Req, KR>> {\n//   return obj(omit(optional, optKeys), omit(required, reqKeys), name)\n// }\n\nexport function objCombine<\n  Opt extends Props,\n  Req extends Props,\n  Opt2 extends Props,\n  Req2 extends Props\n>(\n  p: ObjC<Opt, Req>,\n  p2: ObjC<Opt2, Req2>,\n  name?: string,\n): ObjC<Opt & Opt2, Req & Req2> {\n  return obj(\n    { ...p.optional, ...p2.optional },\n    { ...p.required, ...p2.required },\n    name,\n  )\n}\n\nexport function toOpt<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n  name?: string,\n): ObjC<Req & Opt, {}> {\n  return opt(spec.props, name)\n}\n\nexport function toReq<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n  name?: string,\n): ObjC<{}, Req & Opt> {\n  return req(spec.props, name)\n}\n\nexport function toExact<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n  name?: string,\n): ExactObjC<Opt, Req> {\n  return exactObj(spec.optional, spec.required, name)\n}\n\n// export function pickByValue\n\nexport type ObjCPickBy<Opt extends Props, Req extends Props, ValueType> = ObjC<\n  PickByValue<ObjC<Opt, Req>['required'], ValueType>,\n  PickByValue<ObjC<Opt, Req>['optional'], ValueType>\n>\n\nexport function pickBy<\n  Opt extends Props,\n  Req extends Props,\n  Picks extends Mixed[]\n>(\n  spec: ObjC<Opt, Req>,\n  ...picks: Picks\n): ObjCPickBy<Opt, Req, typeof picks[number]> {\n  function isSpec(\n    names: readonly string[],\n  ): (spec: Mixed) => Mixed | undefined {\n    return spec => (names.includes(spec.name) ? spec : undefined)\n  }\n\n  return obj(\n    buildObject(spec.required, isSpec(picks.map(s => s.name))),\n    buildObject(spec.optional, isSpec(picks.map(s => s.name))),\n  ) as any\n}\n\nexport function pickStrings<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<Opt, Req, StringC> {\n  return pickBy(spec, string)\n}\n\nexport function pickNumbers<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<Opt, Req, NumberC> {\n  return pickBy(spec, number)\n}\n\nexport function pickInts<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<Opt, Req, BrandC<NumberC, IntBrand>> {\n  return pickBy(spec, Int)\n}\n\nexport function pickNumeric<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<Opt, Req, NumberC | BrandC<NumberC, IntBrand>> {\n  return pickBy(spec, number, Int)\n}\n\nexport function pickStringly<Opt extends Props, Req extends Props>(\n  spec: ObjC<Opt, Req>,\n): ObjCPickBy<\n  Opt,\n  Req,\n  NumberC | BrandC<NumberC, IntBrand> | StringC | BooleanC\n> {\n  return pickBy(spec, Int, number, string, boolean)\n}\n"],"names":["warn","condition","message","text","console","Error","x","debug","fatal","error","verify","assert","interval","f","nop","Promise","resolve","setInterval","timeout","delay","setTimeout","freeze","v","process","Object","jsonStringify","obj","JSON","stringify","undefined","rangeInternal","start","stop","step","result","i","push","range","repeatedly","n","buildArray","keys","buildObject","k","today","startOfDay","Date","ISODate","union","date","DateFromISOString","pick","ks","includes","omit","toPromise","either","isRight","right","rejected","decoded","reject","string","is","PathReporter","report","join","cast","spec","args","decode","verifyCast","assertCast","debugCast","lit","literal","pickProps","props","omitProps","tupleChecked","argSpecs","resultSpec","checked","codecs","tuple","tupleCheckedAsync","checkedAsync","toInt","from","IntFromString","toBoolean","BooleanFromString","toNumber","NumberFromString","toDate","DateOnly","brand","EnumType","name","validate","encode","Type","enums","u","c","success","failure","identity","enumerate","ObjType","optional","required","newObj","intersection","readonly","partial","type","newExactObj","exact","exactObj","req","opt","getProps","getProp","prop","empty","NumberType","StringType","BooleanType","KeyofType","LiteralType","value","NullType","UndefinedType","VoidType","UnknownType","InterfaceType","PartialType","ExactType","ReadonlyType","RefinementType","ReadonlyArrayType","ArrayType","AnyArrayType","IntersectionType","types","map","reduce","acc","UnionType","TupleType","isType","t","isStruct","meta","kind","isInterface","isIntersection","isMaybe","isUnion","isEnums","isTuple","isList","isDict","isIrreducible","isInteger","emptyFromIrreducible","rt","emptyFromRT","emptyFromPrimitiveValue","number","boolean","emptyFromObjectValue","emptyFromValue","Array","UnknownRecord","FnType","fn","id","inner","IntID","Int","StrID","Positive","refinement","Number","Negative","Min","min","Max","max","PositiveInt","Integer","NegativeInt","MinInt","MaxInt","rEmail","rUrl","Email","String","s","test","Url","Lower","toLowerCase","Upper","toUpperCase","Length","len","length","MinStringLength","MaxStringLength","Literal","MinDate","d","compareAsc","MaxDate","ArrayMinLength","arr","ArrayMaxLength","rtFromObjectSpec","options","strict","tcomb","struct","rtFromSpec","Boolean","of","Nil","Any","p","maybe","predicate","list","rtFromPrimitiveValue","RegExp","Function","rtFromArrayValue","rtFromValue","rtFromObjectValue","capitalize","arg","slice","toLower","delimiter","camelCaseToHyphenated","camelCaseToSpaced","camelCaseToPhrase","chop","endsWith","extractSegment","fromIndex","upto","indexOf","trim","capitalizeAll","str","joinDelimiter","split","TimeOnly","objPick","objOmit","objCombine","p2","toOpt","toReq","toExact","pickBy","isSpec","names","picks","pickStrings","pickNumbers","pickInts","pickNumeric","pickStringly"],"mappings":"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"}